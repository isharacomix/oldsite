---
layout: post
title: The Github Way
tags: blog
---

For the first time in a long, long, long time, I've finally gotten back into coding. We've started developing a new website for the <a href="http://lug.ncsu.edu">Linux Users Group</a>, and I've actually be contributing to it. Nothing major, just little features here and there to get some experience with the Github way of working on things. Github is a really awesome tool for collaboration, and while I often extol the virtues of the open source way, I haven't really been leading by example, making me a very poor teacher.

On Github, when you want to contribute to a project, you start by forking the project. This creates a completely local copy of the project that becomes your playground and working space. Rather than giving all developers on the project direct writing access to the main project line, each developer will check out their fork, make their changes, test them, and push all of the commits back to their own repository. Then, they submit a "pull request" to the main project maintainers, allowing a project leader to inspect the code, touch it up, and then merge those changes into the final project proper. While this sounds very simple, actually getting involved in the process myself has exposed me to some very subtle, but very beautiful aspects to the entire workflow.

The first is the idea of branching. When you fork a project, you are getting an exact copy of the project, and when you merge it, any changes are made as if they were made on the original. This makes it somewhat tricky to see where particular changes came from and why they were made. So to deal with this, you take advantage of a Git feature called "branching". Branching creates a parallel version of the repository where all commits are given a label based on the branch. The main branch of the project is referred to as the "Master", and my sub-branch might be referred to as "Twitter Plugin". When I finally get finished with my feature, I submit a pull request to take my "Twitter Plugin" branch (not my master branch) and merge it into the original project's master branch. When this is done, the commits that occurred during a specific branch are clearly marked, making it easier to track and see where certain changes occurred so you can blame developers for messing things up.

However, the subtle beauty doesn't stop there. Because I'm new to Django, I had to have my code reviewed, and it naturally required changes. So when the project lead was reviewing my code, he would tell me I need to make changes, and I could push those changes to my repository. The important part here isn't immediately obvious, but because I submitted a pull request for my branch, and not any individual version, it means that when the merge is completed, it will take the newest copy of my branch, and not the one that was live when I originally submitted the pull request. This means that I can still work in the branch safely while going through the code review phase, and the project maintainer doesn't even have to touch my code - he can just merge it when he's happy with it.

This is tremendously beautiful, because this encourages cooperation while reducing bottlenecks. Granted, because it was only two of us, the process was probably much simpler than it would have been. However, it was still much more effective than me writing individual patch files and going multiple rounds of e-mail back and forth before getting anything done, and it was much safer than me having <em>carte blanche</em> access to the repository with no experience under my belt.

The reason why this is important is because I'm developing <a href="http://8bitmooc.org">my own MOOC</a> on Github as a bit of an experiment. I want to understand the workflow so that if I ever get any collaborators, I'll be able to work with them seamlessly. Open source is about structured chaos, and Github feels structured in all the right ways.
