---
layout: post
title: Teaching Philosophies for Computer Science
---

These past few days, I had the pleasure of attending three seminars held by various Computer Science instructors around the country (one of whom was a former instructor of mine while he was a Grad student!), and I got to hear some really awesome talks regarding their experiences and philosophies of Computer Science Education. Each speaker shared with us some of the techniques they like to use in class, discussed their guiding principles, and gave a short sample of a lecture that they would give in one of their classes. Of course, these talks managed to fill up three of the required eight seminars I have to go to during the course of my Ph.D. (only two to go, by the way). However, their value was really in how much insight they provided on how teaching Computer Science is a very different beast than some other subjects.

There were three key points that transcended the talks themselves, and made themselves very apparent over the past week: the need to engage your audience, to establish relevance between the material and the "real world", and to build an intimate intuition and understanding of the material. While the pedagogical techniques were all very different, the key points were consistently mentioned. Computer Science is a bizarre mixture of theoretical logical principles and practical engineering methodologies, which can be unwieldy at first, but is actually a very powerful mix when used properly.

As a theoretically-minded person, I appreciate it when Computer Science topics are introduced in their most abstract sense. When I took my introductory course in Data Structures and Algorithms, the subjects were not introduced using an actual programming language, but using Lisp-like constructs such as <strong>cons</strong>, <strong>car</strong> (first), and <strong>cdr</strong> (rest). We showed that nearly every algorithm that processes a list of elements can be composed of these three simple functions, and this helped ground the ideas that developing algorithms for solving problems is independent of the language used. I'm currently wrapping up a course in Database Management Systems, and our professor has also decided to pursue a "theory-first" teaching approach, and thanks to her consistent teaching style and methodical presentation, the abstract concepts about databases stick with me, and we get a chance to apply them in practice in our semester project.

However, not everyone gets as excited about formal theory as I do, and I recognize this. One of the great things about computers is that they are so easy to change and tinker with, which makes them very effective and engaging tools for leveraging the curiosity of students for teaching. By providing working code and inviting students to alter it and see the effects, they get to learn by trial-and-error, which is how we learn to do many things in our lives, like walking and speaking. Mistakes make for great teaching opportunities, after all, and students can develop an intuition from the experiences they get from successful and failed compilations. We don't learn to speak by learning about the fundamentals of linguistics first - we just learn from our environment and develop an <i>imperfect, but passable</i> ability to speak. The theory can be filled in later, using the experiences to provide some context.

It would be a lot of fun to apply these ideas to teaching folks how to program for the <a href="http://0x10c.com">DCPU-16</a>, but I'll have to wait until the game starts to stabilize, first! I don't really know what the best mix of these two approaches are, since neither one can be used on its own, but I'm sure I'll have a chance to find out what works for me one of these days - hopefully sooner rather than later.
